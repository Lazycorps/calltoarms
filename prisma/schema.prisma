datasource db {
    provider          = "postgresql"
    url               = env("DATABASE_URL")
    shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

generator client {
    provider      = "prisma-client-js"
    binaryTargets = ["native", "rhel-openssl-1.0.x", "debian-openssl-3.0.x"]
}

model User {
    id                    String                 @id
    name                  String
    slug                  String
    createDate            DateTime               @default(now())
    updateDate            DateTime               @default(now())
    admin                 Boolean                @default(false)
    friends               Friend[]               @relation("user_friends")
    friendsOf             Friend[]               @relation("friend_friends")
    sentNotifications     Notification[]         @relation("sender")
    receivedNotifications NotificationReceiver[] @relation("receiver")
    fcmTokens             FcmToken[]
    platformAccounts      PlatformAccount[]
}

model Game {
    id           Int            @id @default(autoincrement())
    title        String
    description  String?
    releaseDate  DateTime?
    imageUrl     String?
    createdAt    DateTime       @default(now())
    updatedAt    DateTime       @updatedAt
    Notification Notification[]
}

model Friend {
    id        Int          @id @default(autoincrement())
    userId    String
    friendId  String
    status    FriendStatus @default(PENDING)
    user      User         @relation("user_friends", fields: [userId], references: [id])
    friend    User         @relation("friend_friends", fields: [friendId], references: [id])
    createdAt DateTime     @default(now())
    updatedAt DateTime     @updatedAt

    @@unique([userId, friendId])
}

enum FriendStatus {
    PENDING
    ACCEPTED
    DECLINED
    BLOCKED
}

model Notification {
    id        Int                    @id @default(autoincrement())
    title     String
    body      String
    senderId  String
    gameId    Int?
    gameCover String?
    sender    User                   @relation("sender", fields: [senderId], references: [id])
    game      Game?                  @relation(fields: [gameId], references: [id])
    receivers NotificationReceiver[]
    createdAt DateTime               @default(now())
}

model NotificationReceiver {
    id             Int          @id @default(autoincrement())
    notificationId Int
    receiverId     String
    read           Boolean      @default(false)
    notification   Notification @relation(fields: [notificationId], references: [id], onDelete: Cascade)
    receiver       User         @relation("receiver", fields: [receiverId], references: [id])
    createdAt      DateTime     @default(now())
}

model FcmToken {
    id        Int      @id @default(autoincrement())
    userId    String
    token     String   @unique
    user      User     @relation(fields: [userId], references: [id])
    createdAt DateTime @default(now())
}

// Énumération des plateformes de jeux
enum GamingPlatform {
    STEAM
    PLAYSTATION
    XBOX
    NINTENDO
    EPIC_GAMES
    GOG
    RIOT
}

// Comptes de plateformes liés à l'utilisateur
model PlatformAccount {
    id           Int            @id @default(autoincrement())
    userId       String // Référence à l'utilisateur
    platform     GamingPlatform // Type de plateforme
    platformId   String // ID sur la plateforme (Steam ID, PSN ID, etc.)
    username     String? // Nom d'utilisateur sur la plateforme
    displayName  String? // Nom d'affichage
    avatarUrl    String? // URL de l'avatar
    profileUrl   String? // URL du profil
    accessToken  String? // Token d'accès (chiffré)
    refreshToken String? // Token de rafraîchissement (chiffré)
    isActive     Boolean        @default(true)
    lastSync     DateTime? // Dernière synchronisation
    user         User           @relation(fields: [userId], references: [id])
    games        PlatformGame[]
    createdAt    DateTime       @default(now())
    updatedAt    DateTime       @updatedAt
    metadata     Json?

    @@unique([userId, platform]) // Un seul compte par plateforme par utilisateur
}

// Jeux sur les différentes plateformes
model PlatformGame {
    id                Int                   @id @default(autoincrement())
    platformAccountId Int // Référence au compte plateforme
    platformGameId    String // ID du jeu sur la plateforme
    name              String // Nom du jeu
    playtimeTotal     Int                   @default(0) // Temps total en minutes
    playtimeRecent    Int? // Temps récent (2 semaines)
    lastPlayed        DateTime? // Dernière fois joué
    iconUrl           String? // URL de l'icône
    coverUrl          String? // URL de la couverture
    isInstalled       Boolean               @default(false)
    isCompleted       Boolean               @default(false) // Jeu terminé par l'utilisateur
    completedAt       DateTime? // Date de completion
    platformAccount   PlatformAccount       @relation(fields: [platformAccountId], references: [id])
    achievements      PlatformAchievement[]
    createdAt         DateTime              @default(now())
    updatedAt         DateTime              @updatedAt

    @@unique([platformAccountId, platformGameId])
}

// Succès/Trophées génériques
model PlatformAchievement {
    id             Int          @id @default(autoincrement())
    platformGameId Int // Référence au jeu
    achievementId  String // ID du succès sur la plateforme
    name           String // Nom du succès
    description    String? // Description
    iconUrl        String? // URL de l'icône
    isUnlocked     Boolean      @default(false)
    unlockedAt     DateTime? // Date de déblocage
    earnedRate     Float?
    rarity         Float? // Rareté (pourcentage)
    points         Int? // Points/Score du succès
    game           PlatformGame @relation(fields: [platformGameId], references: [id])
    createdAt      DateTime     @default(now())
    updatedAt      DateTime     @updatedAt

    @@unique([platformGameId, achievementId])
}
